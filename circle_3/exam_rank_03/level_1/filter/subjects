Assignment name: filter
Expected files: filter.c
Allowed functions and globals: read, write, strlen, memmem, memmove, malloc, calloc, realloc, free, printf, fprintf, stdout, stderr, perror

Write a program that will take one and only one argument s.

Your program will then read from stdin and write all the content read in stdout except that every occurrence of s must be replaced by '*' (as many as the length of s).

Your program will be tested with random buffer sizes, using a custom read function. Therefore the buffer being set in your program will be filled with a different number of chars each new call.

For example:

./filter bonjour
will behave in the same way as:
sed 's/bonjour/*******/g'

./filter abc
will behave in the same way as:
sed's/abc/***/g'

More generally your program must be the equivalent of the shell script filter.sh present in this directory (you can compare your program with it).

In case of error during a read or a malloc, you must write "Error: " followed by the error message in stderr and return 1.

For example this should work:

$> echo 'abcdefaaaabcdeabcabcdabc' | ./filter abc | cat -e
***defaaa***de******d***$
$> echo 'ababcabababc' | ./filter ababc | cat -e
*****ab*****$

--------------------

//If the program is called without arguments or with an empty argument or with multiple arguments, it must return 1.











































filter



#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>


#ifndef BUFFER_SIZE
#define BUFFER_SIZE 42
#endif

void ft_filter

int main(int argc, char **argv)
{

    char *temp[BUFFER_SIZE];
    char *buffer;
    char *res = NULL;
    int total_read;
    ssize_t bytes;

    if(argc != 2)
        return 1;

    while((bytes = read(0, temp, BUFFER_SIZE)) > 0)
    {
        buffer = realloc(res, (total_read + bytes + 1));
        if(!buffer)
        {
            perror("realloc");
            free(buffer);
            return 1;
        }
        res = buffer;
        memmove((res + total_read), temp, bytes);
        total_read = total_read + bytes;
        res[total_read] = '\0';
    }

    if(bytes < 0)
    {
        free(res);
        perror("bytes");
        return 1;
    }
    if(!res)
    {
        free(res);
        return 1;
    }
    ft_filter(res, argv[1]); // function where u find and replace 
    free(res);
    return 0;
}```
