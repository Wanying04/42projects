Minishell

Tan bonito como shell

像 Shell 一样精美

Resumen: El objetivo de este proyecto es que crees un shell sencillo. Sí, tu propio pequeño bash. Aprenderás un montón sobre procesos y descriptores de archivo (file descriptors).

摘要：本项目的目标是帮助您创建一个简单的 Shell。没错，就是您自己的小 Bash。您将学到很多关于进程和文件描述符的知识。

Introducción

简介

La existencia de los shells se remonta a los orígenes de la informática. Por aquel entonces, todos los programadores estaban de acuerdo en que comunicarse con un ordenador utilizando interruptores de 1/0 era realmente frustrante. Era cuestión de tiempo que llegaran a la idea de crear un software para comunicarse con los ordenadores utilizando líneas de comando interactivas en un lenguaje parecido al
utilizado por los humanos. Gracias a Minishell, podrás viajar en el tiempo y volver a los problemas a los que la gente se enfrentaba cuando Windows no existía.

Shell 的历史可以追溯到计算机诞生之初。当时，所有程序员都认为使用 I/O 开关与计算机通信非常令人沮丧。他们最终萌生了使用类似人类语言的交互式命令行与计算机通信的想法。Minishell 让您可以回到过去，重温 Windows 出现之前人们面临的那些问题。

Instrucciones generales

常规说明

• Tu proyecto deberá estar escrito en C.
• Tu proyecto debe estar escrito siguiendo la Norma. Si tienes archivos o funciones adicionales, estas están incluidas en la verificación de la Norma y tendrás un 0 si hay algún error de norma en cualquiera de ellos.
• Tus funciones no deben terminar de forma inesperada (segfault, bus error, double free, etc) excepto en el caso de comportamientos indefinidos. Si esto sucede, tu proyecto será considerado no funcional y recibirás un 0 durante la evaluación.
• Toda la memoria asignada en el heap deberá liberarse adecuadamente cuando sea necesario. No se permitirán leaks de memoria.
• Si el enunciado lo requiere, deberás entregar un Makefile que compilará tus archivos fuente al output requerido con las flags -Wall, -Werror y -Wextra, utilizar cc y por supuesto tu Makefile no debe hacer relink.
• Tu Makefile debe contener al menos las normas $(NAME), all, clean, fclean y re.
• Para entregar los bonus de tu proyecto deberás incluir una regla bonus en tu Makefile, en la que añadirás todos los headers, librerías o funciones que estén prohibidas en la parte principal del proyecto. Los bonus deben estar en archivos distintos _bonus.{c/h}. La parte obligatoria y los bonus se evalúan por separado.
• Si tu proyecto permite el uso de la libft, deberás copiar su fuente y sus Makefile asociados en un directorio libft con su correspondiente Makefile. El Makefile de tu proyecto debe compilar primero la librería utilizando su Makefile, y después compilar el proyecto.
• Te recomendamos crear programas de prueba para tu proyecto, aunque este trabajo no será entregado ni evaluado. Te dará la oportunidad de verificar que tu programa funciona correctamente durante tu evaluación y la de otros compañeros. Y sí, tienes permitido utilizar estas pruebas durante tu evaluación o la de otros compañeros.
• Entrega tu trabajo en tu repositorio Git asignado. Solo el trabajo de tu repositorio Git será evaluado. Si Deepthought evalúa tu trabajo, lo hará después de tus compañeros. Si se encuentra un error durante la evaluación de Deepthought, esta habrá terminado.

• 您的项目必须使用 C 语言编写。
• 您的项目必须遵循标准。如果您有其他文件或函数，这些文件或函数将包含在标准检查中，如果其中任何一个文件或函数存在任何标准错误，您将收到 0 分。
• 除非出现未定义行为，否则您的函数不得意外终止（例如段错误、总线错误、重复释放等）。如果发生这种情况，您的项目将被视为无法运行，并且您将在评估期间收到 0 分。
• 所有在堆上分配的内存都必须在必要时正确释放。内存泄漏是不允许的。
• 如果声明要求，您必须提交一个 Makefile，该文件将使用 -Wall、-Werror 和 -Wextra 标志将您的源文件编译为所需的输出，并使用 cc，当然，您的 Makefile 不得重新链接。
• 您的 Makefile 必须至少包含 $(NAME)、all、clean、fclean 和 re 规则。
• 要为您的项目提交奖励，您必须在 Makefile 中包含一条奖励规则，在该规则中添加项目主体部分中禁止的所有头文件、库或函数。奖励必须放在单独的 _bonus.{c/h} 文件中。强制部分和奖励将分开评估。 
• 如果您的项目允许使用 libft，您必须将其源代码和相关的 Makefile 复制到包含相应 Makefile 的 libft 目录中。您项目的 Makefile 必须先使用其 Makefile 编译库，然后再编译项目。
• 我们鼓励您为您的项目创建测试程序，但这些程序不会被提交或评分。这将使您有机会在您自己和其他同行的评估中验证您的程序是否正常工作。是的，您可以在您自己或其他同行的评估中使用这些测试。
• 将您的作品提交到您指定的 Git 仓库。只有您 Git 仓库中的作品才会被评分。如果 Deepthought 对您的作品进行评分，它将在您的同行评估之后进行。如果在 Deepthought 的评估过程中发现错误，则评估结束。

Instrucciones sobre la IA

AI 指令

● Contexto
Durante tu proceso de aprendizaje, la IA puede ayudarte con muchas tareas diferentes. Tómate el tiempo necesario para explorar las diversas capacidades de las herramientas de IA y cómo pueden apoyarte con tu trabajo. Sin embargo, siempre debes abordarlas con precaución y evaluar de forma crítica los resultados. Ya sea código, documentación, ideas o explicaciones técnicas, nunca podrás saber con total certeza si tu pregunta está bien formulada o si el contenido generado es el adecuado. Las personas que te rodean son tu recurso más valioso para ayudarte a evitar errores y puntos ciegos.

● 背景
在您的学习过程中，AI 可以帮助您完成许多不同的任务。花时间探索 AI 工具的各种功能以及它们如何支持您的工作。但是，您应始终谨慎对待它们，并批判性地评估其结果。无论是代码、文档、想法还是技术说明，您永远无法完全确定您的问题是否表述得当，或者生成的内容是否合适。您周围的人是您最宝贵的资源，可以帮助您避免错误和盲点。

● Mensaje principal:
☛ Utiliza la IA para reducir las tareas repetitivas o tediosas.
☛ Desarrolla habilidades de prompting, ya sea para programacion o para otros temas, que beneficiarán tu futura carrera.
☛ Aprende cómo funcionan los sistemas de IA para anticipar de forma eficiente y evitar los riesgos comunes, sesgos y problemas éticos.
☛ Sigue trabajando con tus compañeros para desarrollar tanto habilidades técnicas como habilidades transversales.
☛ Utiliza únicamente contenido generado por IA que entiendas completamente y del cual puedas responsabilizarte.

● 主要信息：
☛ 使用 AI 减少重复或繁琐的任务。
☛ 培养提示技能，无论是针对编程还是其他科目，这都将对您未来的职业生涯大有裨益。
☛ 了解 AI 系统如何有效地预测和避免常见的风险、偏见和道德问题。
☛ 继续与您的同事合作，培养技术和软技能。
☛ 仅使用您完全理解并能够承担责任的 AI 生成内容。

Reglas para estudiantes:
• Debes tomarte el tiempo necesario para explorar las herramientas de IA y comprender cómo funcionan, para poder utilizarlas de manera ética y reducir los sesgos potenciales.
• Debes reflexionar sobre tu problema antes de dar instrucciones a la IA. Esto te ayuda a escribir preguntas, instrucciones o conjuntos de datos más claros, detalladas y relevantes utilizando un vocabulario preciso.
• Debes desarrollar el hábito de revisar, cuestionar y probar sistemáticamente cualquier contenido generado por la IA.
• Debes buscar siempre la revisión de otras personas, no te limites a confiar en tu propia validación.

学生须知：
• 你必须花时间探索人工智能工具并了解其工作原理，以便合乎道德地使用它们并减少潜在的偏见。
• 在向人工智能发出指令之前，你必须反思你的问题。这有助于你使用精准的词汇，编写更清晰、更详细、更相关的问题、指令或数据集。
• 你必须养成系统地审查、质疑和测试任何人工智能生成内容的习惯。
• 你应该始终寻求他人的反馈，而不是仅仅依靠自己的验证。

Resultados de esta etapa:
• Desarrollar habilidades de prompting tanto generales como de ámbito especifico.
• Aumentar tu productividad con un uso eficaz de las herramientas de IA.
• Seguir fortaleciendo el pensamiento computacional, la resolución de problemas, la adaptabilidad y la colaboración.

此阶段的成果：
• 培养通用和特定领域的提示技能。
• 通过有效使用人工智能工具来提高你的工作效率。
• 继续加强计算思维、解决问题、适应能力和协作能力。

Comentarios y ejemplos:
• Ten en cuenta que la IA puede no tener la respuesta correcta porque esa respuesta no esté ni siquiera en Internet. Además, si te da soluciones incorrectas, intenta no insistir y busca ayuda entre las personas que te rodean. Vas a ahorrarte tiempo y vas a sumar en compresión.
• Vas a enfretarte con frecuencia a situaciones (como exámenes o evaluaciones) donde debes demostrar una comprensión real. Prepárate, sigue construyendo tanto tus habilidades técnicas como transversales.
• Explicar tu razonamiento y debatir con otras personas suele revelar lagunas en tu comprensión de un concepto. Prioriza el aprendizaje entre pares.
• Lo normal es que la herramienta de IA que utilices no conozca tu contexto específico (a menos que se lo indiques), así que te dará respuestas genéricas. Si buscas información más adecuada y más precisa en relación a tu entorno cercano, confía en el resto de estudiantes.
• Donde la IA tiende a generar la respuesta más probable, el resto de estudiantes puede proporcionar perspectivas alternativas y matices valiosos. Confía en la comunidad de 42 como un punto de control de calidad.

评论和示例：
• 请记住，AI 可能没有正确答案，因为这个答案甚至在网上都找不到。此外，如果它给出了错误的答案，尽量不要坚持，并向周围的人寻求帮助。这样可以节省时间并加深理解。
• 你会经常遇到需要展现真正理解的情况（例如考试或评估）。做好准备，继续提升你的技术和软技能。
• 解释你的推理并与他人辩论通常可以揭示你对某个概念理解上的差距。优先考虑同伴学习。
• 通常情况下，你使用的 AI 工具不会了解你的具体情况（除非你告诉它），所以它会给你通用的答案。如果你正在寻找与你当前环境相关的更合适、更准确的信息，请相信其他学生。
• 当 AI 倾向于给出最有可能的答案时，其他学生可以提供不同的观点和有价值的细微差别。依靠 42 社区作为质量控制点。

✓ Buenas prácticas:
Le pregunto a la IA: "¿Cómo pruebo una función de ordenación?"Me da algunas ideas. Las pruebo y reviso los resultados con otra persona. Refinamos el enfoque de manera conjunta.

✓ 最佳实践：
我问人工智能：“如何测试一个排序函数？”它给了我一些想法。我测试了这些想法，并与其他人一起审查结果。我们一起改进了方法。

✗ Bad practice:
Le pido a la IA que escriba una función completa, la copio y la pego en mi proyecto. Durante la evaluación entre pares, no puedo explicar qué hace ni por qué. Pierdo credibilidad. Suspendo mi proyecto.

✗ 不良实践：
我要求人工智能编写一个完整的函数，复制并粘贴到我的项目中。在同行评审期间，我无法解释它的作用和原因。我失去了信誉。我的项目失败了。

✓ Good practice:
Utilizo la IA para ayudarme a diseñar un parser. Luego, reviso la lógica con otra persona. Encontramos dos errores y lo reescribimos juntos: mejor, más limpio y comprendiendo al 100

✓ 良好实践：
我使用人工智能帮助我设计一个解析器。然后，我与其他人一起审查逻辑。我们发现了两个错误，并一起重写了它：更好、更简洁，并且完全理解。

✗ Bad practice:
Dejo que Copilot genere mi código para una parte clave de mi proyecto. Compila, pero no puedo explicar cómo maneja los pipes. Durante la evaluación, no puedo justificarlo y suspendo mi proyecto.

✗ 不良实践：
我让 Copilot 为我项目的一个关键部分生成代码。它可以编译，但我无法解释它如何处理管道。在评审期间，我无法证明这一点，我的项目失败了。

Parte obligatoria

必修部分

Nombre de programa: minishell
Archivos a entregar: Makefile, *.h, *.c
Makefile: NAME, all, clean, flean, re
Argumentos:
Funciones autorizadas: readline, rl_clear_history, rl_on_new_line, rl_replace_line, rl_redisplay, add_history, printf, malloc, free, write, access, open, read, close, fork, wait, waitpid, wait3, wait4, signal, sigaction, sigemptyset, sigaddset, kill, exit, getcwd, chdir, stat, lstat, fstat, unlink, execve, dup, dup2, pipe, opendir, readdir, closedir, strerror, perror, isatty, ttyname, ttyslot, ioctl, getenv, tcsetattr, tcgetattr, tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs
Se permite usar libft: Sí
Descripción: Escribe un shell

程序名称：minishell
待交付文件：Makefile、*.h、*.c
Makefile：NAME、all、clean、flean、re
参数：
授权函数：readline、rl_clear_history、rl_on_new_line、rl_replace_line、rl_redisplay、add_history、printf、malloc、free、write、access、open、read、close、fork、wait、waitpid、wait3、wait4、signal、seguiraction、sigemptyset、seguirddset、kill、exit、getcwd、chdir、stat、lstat、fstat、unlink、execve、dup、dup2、pipe、opendir、readdir、closedir、strerror、perror、isatty、ttyname、ttyslot、ioctl、getenv、tcsetattr、tcgetattr、tgetent tgetflag、tgetnum、tgetstr、tgoto、tputs
Libft 是否允许：是
描述：编写一个 shell

Tu shell deberá:
• Mostrar una entrada mientras espera un comando nuevo.
• Tener un historial funcional.
• Buscar y ejecutar el ejecutable correcto (basado en la variable PATH o mediante el uso de rutas relativas o absolutas).
• Usa como máximo una variable global para indicar la recepción de una señal. Piensa en lo que implica: Esta aproximación evita que tu gestor de señales acceda a tus estructuras de datos principales.

您的 shell 应该：
• 在等待新命令时显示输入。
• 具有功能历史记录。
• 查找并执行正确的可执行文件（基于 PATH 变量或使用相对路径或绝对路径）。
• 最多使用一个全局变量来指示信号的接收。请考虑以下后果：此方法会阻止信号处理程序访问主数据结构。

¡Cuidado! Esta variable global no puede proporcionar ninguna información o dato más allá del número de la señal recibida. Por lo tanto, está prohibido utilizar estructuras de tipo “norm” como variables globales.

注意！此全局变量不能提供除接收信号编号之外的任何信息或数据。因此，禁止使用“norm”结构作为全局变量。

• No interpretar comillas sin cerrar o caracteres especiales no especificados en el enunciado como \ (barra invertida) o ; (punto y coma).
• Gestionar que la ’ evite que el shell interprete los metacaracteres en la secuencia entrecomillada.
• Gestionar que la " evite que el shell interprete los metacaracteres en la secuencia entrecomillada exceptuando $ (signo de dólar).
• Implementar redirecciones:
◦ < debe redirigir la entrada (input).
◦ > debe redirigir la salida (output).
◦ “<<” debe recibir un delimitador, después leer del input de la fuente actual hasta que una línea que contenga solo el delimitador aparezca. Sin embargo, no necesita actualizar el historial.
◦ “>>” debe redirigir la salida (output) en modo de adición (append).
• Implementar tuberías (pipes) (carácter |). El salida (output) de cada comando en la cadena de comandos (pipeline) se conecta mediante una tubería (pipe) a la entrada (input) del siguiente comando.
• Gestionar las variables de entorno ($ seguidos de caracteres) que deberán expandirse a sus valores.
• Gestionar $?, que deberá expandirse al estado de salida del comando más reciente ejecutado en la pipeline.
• Gestionar ctrl-C ctrl-D ctrl-\, que deberán funcionar como en bash.
• Cuando sea interactivo:
◦ ctrl-C imprime una nueva entrada en una línea nueva.
◦ ctrl-D termina el shell.
◦ ctrl-\ no hace nada.
• Deberá implementar los built-ins:
◦ echo con la opción -n.
◦ cd solo con una ruta relativa o absoluta.
◦ pwd sin opciones.
◦ export sin opciones.
◦ unset sin opciones.
◦ env sin opciones o argumentos.
◦ exit sin opciones.
La función readline() puede producir algunos leaks que no necesitas arreglar. Eso no significa que tu código, sí, el código que has escrito, pueda producir leaks.

• 不要解释未闭合的引号或语句中未指定的特殊字符，例如 \（反斜杠）或 ;（分号）。
• 确保 ' 字符可防止 Shell 解释引号序列中的元字符。
• 管理 " 以防止 Shell 解释引号序列中除 $（美元符号）之外的元字符。
• 实现重定向：
◦ < 必须重定向输入。
◦ > 必须重定向输出。
◦ “<<” 必须带有分隔符，然后从当前源读取，直到出现仅包含分隔符的行。但是，它不需要更新历史记录。
◦ “>>” 必须以追加模式重定向输出。
• 实现管道（| 字符）。管道中每个命令的输出通过管道连接到下一个命令的输入。
• 管理必须扩展为其值的环境变量（$ 后跟字符）。
• 管理 $?，它必须扩展为管道中执行的最近命令的退出状态。
• 管理 ctrl-C ctrl-D ctrl-\，其工作方式应与 bash 中相同。
• 交互时：
◦ ctrl-C 在新行打印新输入。
◦ ctrl-D 终止 Shell。
◦ ctrl-\不执行任何操作。
• 您必须实现以下内置函数：
◦ 使用 -n 选项的 echo 命令。
◦ 仅使用相对路径或绝对路径的 cd 命令。
◦ 不带选项的 pwd 命令。
◦ 不带选项的 export 命令。
◦ 不带选项的 unset 命令。
◦ 不带选项或参数的 env 命令。
◦ 不带选项的 exit 命令。
readline() 函数可能会产生一些您无需修复的泄漏。但这并不意味着您的代码（是的，您编写的代码）会产生泄漏。

Limítate a hacer lo que pide el enunciado. Cualquier cosa no solicitada no se requiere.
Para cada punto, y en caso de dudas, puedes utilizar bash como una referencia.

只需按照声明要求操作即可。任何未要求的操作都无需执行。
对于每个要点，如有疑问，您可以参考 bash。

Parte extra

额外部分

Tu programa deberá implementar los siguientes puntos:
• && y || con paréntesis para prioridades.
• Los wildcards * deben funcionar para el directorio actual.

你的程序必须实现以下几点：
• 使用括号中的 && 和 || 来设置优先级。
• * 通配符必须适用于当前目录。

Los bonus solo serán evaluados si tu parte obligatoria está PERFECTA. Con PERFECTA queremos naturalmente decir que debe estar completa, sin fallos incluso en el más absurdo de los casos o de mal uso, etc. Significa que si tu parte obligatoria no tiene TODOS los puntos durante la evaluación, tus bonus serán completamente IGNORADOS.

只有当你的必修部分达到“完美”标准时，才会进行奖励评估。“完美”自然是指它必须完整无缺，即使在最荒谬的情况下也没有任何错误或误用等。这意味着，如果你的必修部分在评估过程中没有达到所有要求，你的奖励将被完全忽略。

Entrega y evaluación

提交和评估

Entrega tu proyecto en tu repositorio Git como de costumbre. Solo el trabajo entregado en el repositorio será evaluado durante la defensa. No dudes en comprobar varias veces los nombres de los archivos para verificar que sean correctos. 
Durante la evaluación, es posible que se solicite una breve modificación del proyecto. Esto puede consistir en ajustar ligeramente el comportamiento, modificar unas cuantas líneas de código o incorporar una característica fácil de implementar.
Puede que este paso no sea necesario en todos los proyectos, pero debes tenerlo en cuenta si asi se especifica en la hoja de evaluación. 
Este paso sirve para a verificar tu comprensión real de una parte específica del proyecto. La modificación se puede realizar en cualquier entorno de desarrollo que elijas (por ejemplo, tu configuración habitual), y debería ser factible en unos pocos minutos, a menos que se defina un plazo específico como parte de la evaluación. Por ejemplo, se te puede pedir hacer una pequeña actualización en una función o script, modificar lo que se vería en pantalla o ajustar una estructura de datos para almacenar nueva información, etc. Los detalles (alcance, objetivo, etc.) se especificarán cada hoja de evaluación y pueden variar de una evaluación a otra para el mismo proyecto.

像往常一样将你的项目提交到你的 Git 仓库。只有提交到仓库的工作才会在答辩期间进行评估。请务必仔细检查文件名，确保其正确无误。
在评估过程中，可能会要求对项目进行一些简单的修改。这可能包括略微调整行为、修改几行代码或添加一个易于实现的功能。
此步骤并非对所有项目都是必需的，但如果评估表中有指定，你应该考虑这样做。
此步骤用于验证您对项目特定部分的实际理解。修改可以在您选择的任何开发环境中进行（例如，您常用的设置），并且应该在几分钟内完成，除非评估中定义了特定的时间范围。例如，您可能会被要求对某个函数或脚本进行小幅更新，修改屏幕上显示的内容，或调整数据结构以存储新信息。每个评估表都会详细说明修改内容（范围、目标等），并且同一项目的不同评估可能会有所不同。





