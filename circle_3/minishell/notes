--------------------
--------------------
内建命令(built-ins)

这些在父进程中直接执行，不需要fork

(NOT OUR TASK) 在 Linux shell 中，你可以定义一个与内建命令同名的函数，但要执行真正的内建命令，需要使用 builtin 命令. 当你定义了一个与内建命令（如 echo 或 cd）同名的函数时，直接调用该函数名会执行你定义的函数，而不是 shell 的内建功能. 使用 builtin 命令可以强制 shell 忽略你定义的函数，执行它本来的内建功能.


----------
echo (-n)
功能：输出文本

echo "hello"        # 输出: hello ;默认在输出后添加换行符
echo -n "hello"     # 输出: hello (不换行) ;-n 选项：抑制末尾的换行符

支持多个参数：
echo 1 2 3 4 5             # 输出: 1 2 3 4 5
echo "hello" "world"       # 输出: hello world
echo -n hello world        # 输出: hello world (不换行)
echo -n "line1" "line2"    # 输出: line1line2 (不换行)

$ echo "X""Y" hello
XY hello          # 相邻引号会拼接

多个参数自动用单个空格分隔
引号在参数解析阶段就被去除，echo 看不到引号
echo "" hello 输出 hello（有个空格）
echo -n 输出空字符串但不换行


----------
cd 只支持相对路径或绝对路径
功能：改变当前工作目录

cd /home/user      # 绝对路径
cd Documents       # 相对路径
cd ..              # 相对路径
cd ./src           # 相对路径

不支持的：
cd                      # 无参数（应该报错）❌
cd ~                    # 家目录（应该报错）❌
cd -                    # 上一个目录（应该报错）❌

只处理路径参数，不需要支持选项
需要处理 cd（无参数）的情况

使用 chdir() 系统调用 
#include <unistd.h>
int chdir(const char *path);
const char *path：要切换到的目录路径
返回值：
成功：返回 0
失败：返回 -1 并设置 errno

perror
#include <stdio.h>
void perror(const char *s);
执行过程：
先打印你提供的字符串 "cd"
然后自动添加冒号和空格 ": "
最后添加对应的错误信息


----------
pwd 无选项
功能：打印当前工作目录

pwd                # 输出: /current/directory/path

使用 getcwd() 系统调用
#include <unistd.h>
char *getcwd(char *buf, size_t size);
参数：
char *buf：存储当前工作目录的缓冲区
size_t size：缓冲区的大小
返回值：
成功：返回指向缓冲区的指针（通常是 buf）
失败：返回 NULL 并设置 errno


----------
环境变量就是一些键值对(key-value pairs)，用来存储系统的配置信息。

echo $PATH            # 查看PATH变量
export NAME=value     # 设置环境变量
unset NAME            # 删除环境变量
env                   # 显示所有环境变量

环境变量是操作系统中用于指定运行环境的参数
环境变量是整个电脑操作系统的妈妈变量
环境变量可以分为系统变量（影响所有用户）和用户变量（仅影响特定用户）。
在C语言中环境变量存储在 char **environ 全局变量 (which we can not use) 中
我们需要在minishell内部维护自己的环境变量列表，因为用户可能用export添加新变量，用unset删除变量，这些改动只应该在minishell内部生效
环境变量本质上就是一个字符串数组的管理问题！

1. 字符串格式：
必须是 "变量名=变量值" 格式
变量名不能包含=
变量值可以包含任何字符

2. 内存管理：
用malloc分配新字符串
用free释放不再需要的字符串
注意内存泄漏

3. 数组管理：
保持数组以NULL结尾
添加时检查是否超过最大数量
删除时要移动后续元素

extern 是一个关键字，意思是 "这个变量在别处定义，我在这里只是声明它"。
environ 是 系统已经定义好的全局变量，在C库中已经存在
#include <stdlib.h> / #include <unistd.h>  // 通常environ在stdlib.h中声明了
// 或者
extern char **environ;  // 显式声明


----------
export 无选项
功能：设置环境变量

export MY_VAR=value
export PATH=/new/path:$PATH

格式：export NAME=value
需要更新shell的环境变量列表


----------
unset 无选项
功能：删除环境变量

unset MY_VAR
unset PATH

从环境变量列表中移除指定变量


----------
env 无选项、无参数
功能：显示所有环境变量

env

简单打印所有环境变量


----------
exit 无选项
功能：退出shell

exit
exit 42           # 带退出码

可选参数：退出状态码（默认为0）
不处理选项：像 exit --help 或 exit -n 应该报错
退出码范围：在真正的bash中，退出状态码超出范围时会自动取模
直接退出：使用 exit() 而不是 return





--------------------
--------------------
基础执行流程/外部命令执行

----------
fork()
作用：创建当前进程的完整副本

#include <unistd.h>
pid_t fork(void);

返回值：
< 0：创建失败
= 0：在子进程中
> 0：在父进程中（返回子进程的PID）

子进程获得父进程的完整内存拷贝（写时复制 Copy-on-Write）
子进程继承父进程的所有打开的文件描述符
两个进程从 fork() 返回后并发执行
通过返回值区分父子进程
子进程通常立即调用 exec()
父进程负责等待和清理
注意文件描述符和信号处理的继承


----------
execve()

#include <unistd.h>
int execve(const char *filename, char *const argv[ ], char *const envp[ ]);

函数执行成功时没有返回值，执行失败时的返回值为-1并将错误原因存储在 errno 中。

execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。
filename: 要执行的文件的路径字符串。 该文件必须是可执行二进制文件或以 #! 开头的脚本文件。 
argv: 一个由指针组成的数组，用于传递命令行参数给新程序。
数组的第一个元素 (argv[0]) 通常是新程序的名称。
数组的最后一个元素必须是一个 NULL 指针来终止。
envp: 一个由指针组成的数组，用于传递新程序的环境变量。
每个环境变量都应以 "name=value" 的格式表示。
数组的最后一个元素也必须是一个 NULL 指针。

exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。
进程替换: execve() 通过用新程序替换当前进程的内存、数据段和堆栈段来执行新程序。 它不是创建新进程，而是“覆盖”了现有进程。 
PID 保留: 调用 execve() 后，进程ID (PID) 不会改变。 

fork()和execve()的区别
fork是分身，execve是变身。
在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。
exec系列的系统调用是把当前程序替换成要执行的程序，而fork用来产生一个和当前进程一样的进程（虽然通常执行不同的代码流）。
exec系列的系统调用已经变成别的程序，和本程序无关。


----------
wait, waitpid, wait3, wait4
进程等待函数
#include <sys/wait.h>

pid_t wait(int *wstatus);

作用：等待任意一个子进程结束
参数：wstatus - 存储子进程退出状态
返回值：成功返回子进程PID，失败返回-1

pid_t waitpid(pid_t pid, int *wstatus, int options);

参数：

pid：
> 0：等待指定PID的子进程
-1：等待任意子进程（同wait）
0：等待同进程组的任意子进程
<-1：等待指定进程组的任意子进程

options：
WNOHANG：非阻塞，如果没有子进程退出立即返回0
WUNTRACED：也返回已停止的子进程（比如被信号暂停）
WCONTINUED：也返回已继续运行的子进程

minishell中推荐使用 waitpid()
可以等待特定进程（管道中的多个进程）
支持非阻塞模式（处理后台作业 & 信号）
更灵活的控制选项

pid_t wait3(int *wstatus, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>

额外功能：可以获取子进程的资源使用统计


----------
进程状态

进程是程序运行的过程
进程状态类型有运行、挂起、等待、阻塞、就绪、等待、停止、挂机、死亡等等。

运行 (Running)
含义：进程正在CPU上执行指令

就绪 (Ready)
含义：进程已准备好运行，等待CPU时间片

阻塞/等待 (Blocked/Waiting)
含义：进程等待某个事件或资源

停止 (Stopped)
含义：进程执行被暂停，通常由信号引起

挂起 (Suspended)
含义：进程被移到磁盘交换空间，释放内存

僵尸 (Zombie)
含义：进程已终止，但父进程尚未调用 wait()
如果子进程在处理任务代码过程中异常退出，而父进程却没有回收子进程资源，会导致子进程虽然运行实体已经消失，但仍然在内核的进程表中占据一条记录，长期下去对于系统资源是一个浪费。

死亡/终止 (Terminated)
含义：进程执行完成或被杀死，资源完全释放

孤儿进程
如果子进程在处理任务过程中，父进程退出了，子进程没有退出，那么这些子进程就没有父进程来管理了，由系统的system进程管理。



重要注意事项
参数数组必须以NULL结尾
exec系列函数成功时不返回，失败时才返回-1
记得在子进程中处理错误，用exit()退出
父进程要等待子进程，避免僵尸进程
考虑信号处理（比如Ctrl+C要能终止子进程）

重要提醒
僵尸进程：如果不wait，子进程会变成僵尸
信号干扰：wait可能被信号中断，需要检查errno == EINTR
非阻塞循环：使用WNOHANG时要避免CPU 100%
多个子进程：要确保wait所有子进程




C语言getcwd()函数：取得当前的工作目录

char * getcwd(char * buf, size_t size);

getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。
倘若参数buf 为NULL，getcwd()会依参数size 的大小自动配置内存(使用malloc())，如果参数size 也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，进程可以在使用完次字符串后利用free()来释放此空间。

C语言chdir()函数：改变当前的工作目录

int chdir(const char * path);

chdir()用来将当前的工作目录改变成以参数path所指的目录

成功时返回 \(0\)。失败时返回 \(-1\)，并且全局变量 errno 会被设置，以指明错误原因。
chdir 会自动解析 . 和 ..





--------------------
--------------------
pid_t	pid = fork();

这个语句的意思是定义了一个pid_t类型的变量pid，fork()函数返回一个进程号，这个进程号赋给了pid。


文件描述符的分配

open, dup, dup2, fcntl

dup
函数的作用是复制文件描述符，这样就有多个文件描述符可以指向同一个文件了

int dup(int oldfd);

参数： oldfd 是要被复制的文件描述符
返回值：函数调用成功返回被复制出的文件描述符，调用失败返回 -1
被复制出的新文件描述符是独立于旧的文件描述符的，二者没有连带关系。也就是说当旧的文件描述符被关闭了，复制出的新文件描述符还是可以继续使用的

dup2()

int dup2(int oldfd, int newfd);

基于dup2() 既可以进行文件描述符的复制, 也可以进行文件描述符的重定向。文件描述符重定向就是改变已经分配的文件描述符关联的磁盘文件。
参数: oldfd和``newfd` 都是文件描述符
返回值: 函数调用成功返回新的文件描述符, 调用失败返回 -1

access()函数用来判断用户是否具有访问某个文件的权限(或判断某个文件是否存在)

int access(const char *pathname,int mode) 

参数: 
pathname:表示要测试的文件的路径 
mode:表示测试的模式可能的值有: 
R_OK:是否具有读权限 
W_OK:是否具有可写权限 
X_OK:是否具有可执行权限 
F_OK:文件是否存在 
返回值:若测试成功则返回0,否则返回-1


exit(127) 是 Unix 约定的“命令未找到”错误码。






































1. fork()
Shell, User mode and kernel mode, child progress, parent progress
Under what circumstances will the shell generate a subprocess?

这是42学校的项目吗？如果是的话，Minishell肯定是一个两人小组的项目。一个人负责解析，另一个人负责执行。（通常就是这样的。）

如果您还想完成一些额外的工作（处理通配符和逻辑运算符），解析部分将会更加困难。对于执行部分，您需要了解二叉树的工作原理。示例：Echo hello && echo hello --> 在这种情况下，二叉树的根节点是 &&，在左侧您会找到 echo hello，而在右侧您会找到 echo hello。

解析部分负责创建树，执行部分负责导航和执行树。

除此之外，您还需要很好地理解 C 语言中进程的工作原理。即文件描述符 (fds)、fork、管道等的工作原理。

我建议你先了解每个提供的函数的功能，然后用 readline 创建一个简单的提示符。设置完成后，就可以开始了。我个人先完成了执行器部分，先从内置命令开始，再用路径查找器查找 PATH 环境变量中未内置的命令，最后才开始执行执行器。



同学A的具体任务清单：

第一周任务：
实现基础令牌分割
处理简单命令: ls -l
识别重定向符号: > < >>
识别管道符号: |

第二周任务：
实现引号处理（单引号、双引号）
处理转义字符 \
实现变量扩展 $VAR
构建命令数据结构

第三周任务：
语法错误检测
处理here document <<
内存管理：释放解析器分配的内存
边界情况处理



同学B的具体任务清单：

第一周任务：
实现简单命令执行 ls, pwd
实现内建命令 echo, pwd, cd
基础进程管理 fork(), execve(), waitpid()

第二周任务：
实现输入/输出重定向 <, >
实现管道 |（单个管道）
实现 exit, env 命令
处理文件描述符泄漏

第三周任务：
实现追加重定向 >>
实现here document <<
信号处理 Ctrl+C, Ctrl+\, Ctrl+D
多管道支持 cmd1 | cmd2 | cmd3

数据结构接口：

// 同学A提供的数据结构
typedef struct s_command {
    char **args;           // 命令和参数
    char *input_file;      // 输入文件（NULL表示无）
    char *output_file;     // 输出文件（NULL表示无）
    int append_mode;       // 输出是否追加
    char *heredoc_delimiter; // here document分界符
    struct s_command *next;  // 管道下一个命令
} t_command;

// 同学A提供的函数
t_command *parse_input(char *input);
void free_commands(t_command *cmd);
执行器接口：
c
// 同学B提供的函数  
int execute_commands(t_command *cmd);
int execute_builtin(char **args);
void setup_redirections(t_command *cmd);

同学B：执行器部分
核心职责：执行解析后的命令结构
1. 进程执行管理
c
// 执行外部命令流程：
1. fork() 创建子进程
2. 在子进程中:
   - 设置重定向 (dup2)
   - execve() 执行命令
3. 在父进程中:
   - waitpid() 等待子进程结束
   - 收集退出状态

// 示例执行: ls -l
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    execve("/bin/ls", {"ls", "-l", NULL}, environ);
} else {
    // 父进程  
    waitpid(pid, &status, 0);
}
2. 内建命令实现
c
// 必须实现的内建命令：
- cd:     改变工作目录
- echo:   输出文本，支持 -n 选项
- pwd:    打印当前目录
- export: 设置环境变量
- unset:  取消环境变量
- env:    显示环境变量
- exit:   退出shell

// 示例：cd 命令实现
int builtin_cd(char **args) {
    if (args[1] == NULL) {
        chdir(getenv("HOME"));
    } else {
        if (chdir(args[1]) != 0) {
            perror("cd");
            return 1;
        }
    }
    return 0;
}
3. 重定向处理
c
// 处理所有重定向类型：
- 输入重定向:    cmd < file.txt
- 输出重定向:    cmd > file.txt  
- 追加重定向:    cmd >> file.txt
- here document: cmd << EOF

// 重定向执行流程：
1. 打开文件获取fd
2. 使用dup2重定向stdin/stdout
3. 执行命令
4. 恢复原来的stdin/stdout
4. 管道实现
c
// 处理: cmd1 | cmd2 | cmd3
int pipefd[2];
pipe(pipefd);

// 第一个命令：输出重定向到管道
dup2(pipefd[1], STDOUT_FILENO);
close(pipefd[1]);

// 第二个命令：输入来自管道  
dup2(pipefd[0], STDIN_FILENO);
close(pipefd[0]);
5. 信号处理
c
// 关键信号处理：
- SIGINT (Ctrl+C):  中断当前命令
- SIGQUIT (Ctrl+\): 退出当前命令
- EOF (Ctrl+D):     退出shell

void handle_sigint(int sig) {
    write(1, "\nminishell> ", 12);
}
