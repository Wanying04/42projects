命令类型判断
    ↓
1. 单个命令
    ├─ 1.1 内部命令
    └─ 1.2 外部命令

2. 多个命令（管道）
    ├─ 2.1 处理管道连接
    └─ 2.2 对管道中的每个命令：
            ├─ 2.2.1 如果是内部命令 → 复用 1.1
            └─ 2.2.2 如果是外部命令 → 复用 1.2

Command Type Determination
    ↓
1. Single Command
    ├─ 1.1 Built-in
    └─ 1.2 External

2. Multiple Commands (Pipelines)
    ├─ 2.1 Process pipeline connections
    └─ 2.2 For each command in pipeline:
            ├─ 2.2.1 If built-in → Reuse 1.1
            └─ 2.2.2 If external → Reuse 1.2


circle 4:
netpractice  V
cub3d        V
cpp 00-04    X
exam 04      V

circle 5:
cpp 05-09    X
inception    V
exam 05      X

circle 6:
transferance X
exam 06      X

exam 04 -- 





wtang@c3r2s2:~/minishell$ echo bonjour ; |
bash: syntax error near unexpected token `|'
# 错误：管道符 | 前面必须有命令

minishell$ echo bonjour ; |
bonjour ;
# 输出：bonjour ;
# 管道符被当作普通参数处理
问题原因： minishell 没有正确识别管道符号作为特殊运算符，而是将其当作普通字符串参数。
----------------------------------------

wtang@c3r2s2:~$ echo -n -n -nnnn -nnnnm
-nnnnmwtang@c3r2s2:~$ 
# 输出：-nnnnm（所有 -n 选项都被识别，最后一个参数正常输出）

minishell$ echo -n -n -nnnn -nnnnm
-n -nnnn -nnnnmminishell$ 
# 输出：-n -nnnn -nnnnm（没有识别 -n 选项）
要求："实现 echo 带 -n 选项"
你的 echo 没有正确识别 -n 选项
需要修复：连续多个 -n 应该被识别为选项，只有最后一个非选项参数才输出
----------------------------------------

wtang@c3r2s2:~$ unset var1 # with undefined var1
wtang@c3r2s2:~$ 
# 静默成功，无错误

minishell$ unset var1 # with undefined var1
unset: not a valid identifier
# 错误：not a valid identifier
要求："实现 unset 不带选项"
标准行为：unset 未定义的变量应该静默成功
需要修复：unset 应该能够处理未定义的变量而不报错
----------------------------------------

wtang@c3r2s2:~$ echo test > file test1
wtang@c3r2s2:~$
# 创建文件 "file"，内容为 "test"
# 在终端输出 "test1"

minishell$ echo test > file test1
test test1
# 输出：test test1
# 没有重定向
要求明确说明要实现重定向：> 必须重定向输出
你的 minishell 没有识别重定向符号，而是将其当作普通参数
必须修复：echo test > file 应该创建文件 "file" 并写入 "test"
----------------------------------------

wtang@c3r2s2:~$ env puis export puis env # vars aren't sorted
env: ‘puis’: No such file or directory
# 执行：env，然后 export，然后 env
# 注释被忽略

minishell$ env puis export puis env # vars aren't sorted
minishell: syntax error: unclosed quotes
# 错误：unclosed quotes
要求明确说明："不要解释未闭合的引号
你的 minishell 错误地将 # 后面的内容当作未闭合引号
必须修复：正确处理注释符号 #，它后面的内容应该被忽略
----------------------------------------

wtang@c3r2s2:~$ echo 2 >> out1 > out2
wtang@c3r2s2:~$
# 标准 bash: 无输出，正确重定向

minishell$ echo 2 >> out1 > out2
2
# 你的 minishell: 输出 "2"，重定向可能有问题
问题原因：重定向执行顺序或文件描述符管理不正确。bash 会按照从左到右处理重定向，最终输出应该被重定向到文件。
----------------------------------------

wtang@c3r2s2:~$ echo 2 > out1 >> out2
wtang@c3r2s2:~$ 
# 错误：语法错误，不能同时使用 > 和 >>

minishell$ echo 2 > out1 >> out2
2
# 输出：2 （应该报错）
语法错误处理：要求中虽然没有明确说，但 bash 会拒绝这种语法错误
重定向冲突：一个命令不能同时有多个输出重定向
符合 bash 参考：要求说"如有疑问，参考 bash"
----------------------------------------

wtang@c3r2s2:~$ export var; export var=test
wtang@c3r2s2:~$

minishell$ export var; export var=test
export: not a valid identifier
说明：你的 minishell 对 export 的参数验证比 bash 更严格，这是可以接受的。
----------------------------------------

wtang@c3r2s2:~$ echo bonjour > $test # with test not defined
bash: $test: ambiguous redirect
# 标准 bash: 明确的错误信息

minishell$ echo bonjour > $test # with test not defined
bonjour # with test not defined
# 你的 minishell: 执行了 echo，重定向失败
问题原因：当 $test 为空或未定义时，重定向文件名变成空字符串，应该报错而不是忽略重定向。
----------------------------------------

wtang@c3r2s2:/$ $bla # with bla not defined
wtang@c3r2s2:/$
# Bash: 未定义变量扩展为空字符串

minishell$ $bla # with bla not defined
Permission denied
# 错误处理不正确
修复要求：环境变量 $? 和变量扩展是必须实现的功能
----------------------------------------

wtang@c3r2s2:/$ c$var Makefile # with var=at
Test project /
Cannot create directory //Testing/Temporary
Cannot create log file: LastTest.log
No tests were found!!!
# Bash: c + $var = cat

minishell$ c$var Makefile # with var=at
c: command not found
# 你的 minishell: 当作命令 "c"
修复要求：变量扩展必须正确拼接
----------------------------------------

wtang@c3r2s2:/$ $LESS$VAR
wtang@c3r2s2:/$

minishell$ $LESS$VAR
Permission denied
# 符合要求：尝试执行不存在的命令
----------------------------------------

wtang@c3r2s2:/$ echo bonjour > $test w/ t
bash: ici=coucou: Permission denied
# 错误：$test 被扩展为变量，如果 test="ici=coucou"
# 会尝试创建名为 "ici=coucou" 的文件，但权限被拒绝

minishell$ echo bonjour > $test w/ t
bonjour w/ t
# 输出：bonjour w/ t
# $test 没有被扩展为环境变量
"管理必须扩展为其值的环境变量（$ 后跟字符）"
"管理 $?，它必须扩展为管道中执行的最近命令的退出状态"
----------------------------------------

wtang@c3r2s2:/$ cat diufosgid # check exit code
cat: diufosgid: No such file or directory

minishell$ cat diufosgid # check exit code
cat: diufosgid: No such file or directory
cat: '#': No such file or directory
cat: check: No such file or directory
cat: exit: No such file or directory
cat: code: No such file or directory
# 把 # 后面的内容都当作参数了
应该： # 后面的内容应该被忽略
----------------------------------------

wtang@c3r2s2:/$ exit # should return the last exit code value
exit

minishell$ exit # should return the last exit code value
exit: too many arguments
# 错误：把注释当作参数了
----------------------------------------

wtang@c3r2s2:~$ ;
bash: syntax error near unexpected token `;'

minishell$ ;
;: command not found
# 符合要求：分号不解释为分隔符
----------------------------------------

wtang@c3r2s2:~$ echo '$HOME'
$HOME
# 应该输出: $HOME

minishell$ echo '$HOME'
/home/wtang
# 错误：单引号内不应扩展变量
----------------------------------------

export ; env # display is different for both commands
# export: 显示所有导出变量（格式：declare -x VAR=value）
# env: 显示所有环境变量（格式：VAR=value）

minishell$ export ; env # display is different for both commands
export: not a valid identifier
你的 minishell 错误地将 ; 后面的内容当作 export 的参数
虽然要求说"不要解释分号"，但这仅适用于shell语法层面
对于内置命令的参数解析，分号应该被当作普通字符
你的 export 命令错误地将 ; env # display... 整个字符串当作一个变量名
export 内置命令
无参数时：显示所有导出变量
有参数时：设置导出变量
正确处理参数边界
确保内置命令只接收自己的参数，不错误包含后续文本
分号在命令参数中应保持为字面字符
----------------------------------------

wtang@c3r2s2:~$ > log echo coucou
wtang@c3r2s2:~$
# 正确：先重定向到log文件，再执行echo

minishell$ > log echo coucou
coucou
# 错误：直接输出到终端，没有重定向
问题原因：重定向解析顺序错误，应该在命令执行前处理重定向。
----------------------------------------

wtang@c3r2s2:~$ echo "\"
> ^C
 # 等待继续输入（多行输入）

minishell$ echo "\"
minishell: syntax error: unclosed quotes
# 直接报语法错误
问题原因：要求中说"不要解释未闭合的引号"，但应该等待用户继续输入而不是直接报错。
----------------------------------------

wtang@c3r2s2:~$ echo "\n \n \n"
\n \n \n

minishell$ echo "\n \n \n"
minishell: syntax error: invalid escape sequence

wtang@c3r2s2:~$ echo "\n \n \\n"
\n \n \n

minishell$ echo "\n \n \\n"
minishell: syntax error: invalid escape sequence
# 你的行为是正确的（符合要求）：不解释反斜杠
----------------------------------------

wtang@c3r2s2:~$ echo ;;
bash: syntax error near unexpected token `;;'

minishell$ echo ;;
;;
# 你的行为是正确的（符合要求）：输出 ;;（不解释分号）
----------------------------------------

wtang@c3r2s2:/$ echo $?
130

minishell$ echo $?
$?
管理 $?，它必须扩展为管道中执行的最近命令的退出状态
----------------------------------------

wtang@c3r2s2:/$ > a ls > b < Makefile
bash: a: Permission denied

minishell$ > a ls > b < Makefile
open: Permission denied
你的 minishell：open: Permission denied（部分正确）
但应该更优雅地处理，可能需要在执行命令前检查重定向权限
----------------------------------------

wtang@c3r2s2:/$ echo > a Hello World!
bash: a: Permission denied

minishell$ echo > a Hello World!
Hello World!

minishell$ > a echo Hello World!
Hello World!
你的 minishell：在权限被拒绝时仍然执行了 echo
正确行为：如果重定向失败，整个命令应该失败


































--------------------
--------------------
内建命令(built-ins)

这些在父进程中直接执行，不需要fork

(NOT OUR TASK) 在 Linux shell 中，你可以定义一个与内建命令同名的函数，但要执行真正的内建命令，需要使用 builtin 命令. 当你定义了一个与内建命令（如 echo 或 cd）同名的函数时，直接调用该函数名会执行你定义的函数，而不是 shell 的内建功能. 使用 builtin 命令可以强制 shell 忽略你定义的函数，执行它本来的内建功能.


----------
echo (-n)
功能：输出文本

echo "hello"        # 输出: hello ;默认在输出后添加换行符
echo -n "hello"     # 输出: hello (不换行) ;-n 选项：抑制末尾的换行符

支持多个参数：
echo 1 2 3 4 5             # 输出: 1 2 3 4 5
echo "hello" "world"       # 输出: hello world
echo -n hello world        # 输出: hello world (不换行)
echo -n "line1" "line2"    # 输出: line1line2 (不换行)

$ echo "X""Y" hello
XY hello          # 相邻引号会拼接

多个参数自动用单个空格分隔
引号在参数解析阶段就被去除，echo 看不到引号
echo "" hello 输出 hello（有个空格）
echo -n 输出空字符串但不换行


----------
cd 只支持相对路径或绝对路径
功能：改变当前工作目录

cd /home/user      # 绝对路径
cd Documents       # 相对路径
cd ..              # 相对路径
cd ./src           # 相对路径

不支持的：
cd                      # 无参数（应该报错）❌
cd ~                    # 家目录（应该报错）❌
cd -                    # 上一个目录（应该报错）❌

只处理路径参数，不需要支持选项
需要处理 cd（无参数）的情况

使用 chdir() 系统调用 
#include <unistd.h>
int chdir(const char *path);
const char *path：要切换到的目录路径
返回值：
成功：返回 0
失败：返回 -1 并设置 errno

perror
#include <stdio.h>
void perror(const char *s);
执行过程：
先打印你提供的字符串 "cd"
然后自动添加冒号和空格 ": "
最后添加对应的错误信息


----------
pwd 无选项
功能：打印当前工作目录

pwd                # 输出: /current/directory/path

使用 getcwd() 系统调用
#include <unistd.h>
char *getcwd(char *buf, size_t size);
参数：
char *buf：存储当前工作目录的缓冲区
size_t size：缓冲区的大小
返回值：
成功：返回指向缓冲区的指针（通常是 buf）
失败：返回 NULL 并设置 errno


----------
环境变量就是一些键值对(key-value pairs)，用来存储系统的配置信息。

echo $PATH            # 查看PATH变量
export NAME=value     # 设置环境变量
unset NAME            # 删除环境变量
env                   # 显示所有环境变量

环境变量是操作系统中用于指定运行环境的参数
环境变量是整个电脑操作系统的妈妈变量
环境变量可以分为系统变量（影响所有用户）和用户变量（仅影响特定用户）。
在C语言中环境变量存储在 char **environ 全局变量 (which we can not use) 中
我们需要在minishell内部维护自己的环境变量列表，因为用户可能用export添加新变量，用unset删除变量，这些改动只应该在minishell内部生效
环境变量本质上就是一个字符串数组的管理问题！

1. 字符串格式：
必须是 "变量名=变量值" 格式
变量名不能包含=
变量值可以包含任何字符

2. 内存管理：
用malloc分配新字符串
用free释放不再需要的字符串
注意内存泄漏

3. 数组管理：
保持数组以NULL结尾
添加时检查是否超过最大数量
删除时要移动后续元素

extern 是一个关键字，意思是 "这个变量在别处定义，我在这里只是声明它"。
environ 是 系统已经定义好的全局变量，在C库中已经存在
#include <stdlib.h> / #include <unistd.h>  // 通常environ在stdlib.h中声明了
// 或者
extern char **environ;  // 显式声明


----------
export 无选项
功能：设置环境变量

export MY_VAR=value
export PATH=/new/path:$PATH

格式：export NAME=value
需要更新shell的环境变量列表


----------
unset 无选项
功能：删除环境变量

unset MY_VAR
unset PATH

从环境变量列表中移除指定变量


----------
env 无选项、无参数
功能：显示所有环境变量

env

简单打印所有环境变量


----------
exit 无选项
功能：退出shell

exit
exit 42           # 带退出码

可选参数：退出状态码（默认为0）
不处理选项：像 exit --help 或 exit -n 应该报错
退出码范围：在真正的bash中，退出状态码超出范围时会自动取模
直接退出：使用 exit() 而不是 return





--------------------
--------------------
基础执行流程/外部命令执行

----------
fork()
作用：创建当前进程的完整副本

#include <unistd.h>
pid_t fork(void);

返回值：
< 0：创建失败
= 0：在子进程中
> 0：在父进程中（返回子进程的PID）

子进程获得父进程的完整内存拷贝（写时复制 Copy-on-Write）
子进程继承父进程的所有打开的文件描述符
两个进程从 fork() 返回后并发执行
通过返回值区分父子进程
子进程通常立即调用 exec()
父进程负责等待和清理
注意文件描述符和信号处理的继承


----------
execve()

#include <unistd.h>
int execve(const char *filename, char *const argv[ ], char *const envp[ ]);

函数执行成功时没有返回值，执行失败时的返回值为-1并将错误原因存储在 errno 中。

execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。
filename: 要执行的文件的路径字符串。 该文件必须是可执行二进制文件或以 #! 开头的脚本文件。 
argv: 一个由指针组成的数组，用于传递命令行参数给新程序。
数组的第一个元素 (argv[0]) 通常是新程序的名称。
数组的最后一个元素必须是一个 NULL 指针来终止。
envp: 一个由指针组成的数组，用于传递新程序的环境变量。
每个环境变量都应以 "name=value" 的格式表示。
数组的最后一个元素也必须是一个 NULL 指针。

exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。
进程替换: execve() 通过用新程序替换当前进程的内存、数据段和堆栈段来执行新程序。 它不是创建新进程，而是“覆盖”了现有进程。 
PID 保留: 调用 execve() 后，进程ID (PID) 不会改变。 

fork()和execve()的区别
fork是分身，execve是变身。
在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。
exec系列的系统调用是把当前程序替换成要执行的程序，而fork用来产生一个和当前进程一样的进程（虽然通常执行不同的代码流）。
exec系列的系统调用已经变成别的程序，和本程序无关。


----------
wait, waitpid, wait3, wait4
进程等待函数
#include <sys/wait.h>

pid_t wait(int *wstatus);

作用：等待任意一个子进程结束
参数：wstatus - 存储子进程退出状态
返回值：成功返回子进程PID，失败返回-1

pid_t waitpid(pid_t pid, int *wstatus, int options);

参数：

pid：
> 0：等待指定PID的子进程
-1：等待任意子进程（同wait）
0：等待同进程组的任意子进程
<-1：等待指定进程组的任意子进程

options：
WNOHANG：非阻塞，如果没有子进程退出立即返回0
WUNTRACED：也返回已停止的子进程（比如被信号暂停）
WCONTINUED：也返回已继续运行的子进程

minishell中推荐使用 waitpid()
可以等待特定进程（管道中的多个进程）
支持非阻塞模式（处理后台作业 & 信号）
更灵活的控制选项

pid_t wait3(int *wstatus, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>

额外功能：可以获取子进程的资源使用统计


----------
进程状态

进程是程序运行的过程
进程状态类型有运行、挂起、等待、阻塞、就绪、等待、停止、挂机、死亡等等。

运行 (Running)
含义：进程正在CPU上执行指令

就绪 (Ready)
含义：进程已准备好运行，等待CPU时间片

阻塞/等待 (Blocked/Waiting)
含义：进程等待某个事件或资源

停止 (Stopped)
含义：进程执行被暂停，通常由信号引起

挂起 (Suspended)
含义：进程被移到磁盘交换空间，释放内存

僵尸 (Zombie)
含义：进程已终止，但父进程尚未调用 wait()
如果子进程在处理任务代码过程中异常退出，而父进程却没有回收子进程资源，会导致子进程虽然运行实体已经消失，但仍然在内核的进程表中占据一条记录，长期下去对于系统资源是一个浪费。

死亡/终止 (Terminated)
含义：进程执行完成或被杀死，资源完全释放

孤儿进程
如果子进程在处理任务过程中，父进程退出了，子进程没有退出，那么这些子进程就没有父进程来管理了，由系统的system进程管理。



重要注意事项
参数数组必须以NULL结尾
exec系列函数成功时不返回，失败时才返回-1
记得在子进程中处理错误，用exit()退出
父进程要等待子进程，避免僵尸进程
考虑信号处理（比如Ctrl+C要能终止子进程）

重要提醒
僵尸进程：如果不wait，子进程会变成僵尸
信号干扰：wait可能被信号中断，需要检查errno == EINTR
非阻塞循环：使用WNOHANG时要避免CPU 100%
多个子进程：要确保wait所有子进程




C语言getcwd()函数：取得当前的工作目录

char * getcwd(char * buf, size_t size);

getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。
倘若参数buf 为NULL，getcwd()会依参数size 的大小自动配置内存(使用malloc())，如果参数size 也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，进程可以在使用完次字符串后利用free()来释放此空间。

C语言chdir()函数：改变当前的工作目录

int chdir(const char * path);

chdir()用来将当前的工作目录改变成以参数path所指的目录

成功时返回 \(0\)。失败时返回 \(-1\)，并且全局变量 errno 会被设置，以指明错误原因。
chdir 会自动解析 . 和 ..





--------------------
--------------------
pid_t	pid = fork();

这个语句的意思是定义了一个pid_t类型的变量pid，fork()函数返回一个进程号，这个进程号赋给了pid。


文件描述符的分配

open, dup, dup2, fcntl

dup
函数的作用是复制文件描述符，这样就有多个文件描述符可以指向同一个文件了

int dup(int oldfd);

参数： oldfd 是要被复制的文件描述符
返回值：函数调用成功返回被复制出的文件描述符，调用失败返回 -1
被复制出的新文件描述符是独立于旧的文件描述符的，二者没有连带关系。也就是说当旧的文件描述符被关闭了，复制出的新文件描述符还是可以继续使用的

dup2()

int dup2(int oldfd, int newfd);

基于dup2() 既可以进行文件描述符的复制, 也可以进行文件描述符的重定向。文件描述符重定向就是改变已经分配的文件描述符关联的磁盘文件。
参数: oldfd和``newfd` 都是文件描述符
返回值: 函数调用成功返回新的文件描述符, 调用失败返回 -1

access()函数用来判断用户是否具有访问某个文件的权限(或判断某个文件是否存在)

int access(const char *pathname,int mode) 

参数: 
pathname:表示要测试的文件的路径 
mode:表示测试的模式可能的值有: 
R_OK:是否具有读权限 
W_OK:是否具有可写权限 
X_OK:是否具有可执行权限 
F_OK:文件是否存在 
返回值:若测试成功则返回0,否则返回-1


exit(127) 是 Unix 约定的“命令未找到”错误码。




<< e >> a.txt

<< e >> echo >> a.txt

echo >> b.txt << a

echo << e >> c.txt

echo hola << e >> d.txt

<< a << b << c



































1. fork()
Shell, User mode and kernel mode, child progress, parent progress
Under what circumstances will the shell generate a subprocess?

这是42学校的项目吗？如果是的话，Minishell肯定是一个两人小组的项目。一个人负责解析，另一个人负责执行。（通常就是这样的。）

如果您还想完成一些额外的工作（处理通配符和逻辑运算符），解析部分将会更加困难。对于执行部分，您需要了解二叉树的工作原理。示例：Echo hello && echo hello --> 在这种情况下，二叉树的根节点是 &&，在左侧您会找到 echo hello，而在右侧您会找到 echo hello。

解析部分负责创建树，执行部分负责导航和执行树。

除此之外，您还需要很好地理解 C 语言中进程的工作原理。即文件描述符 (fds)、fork、管道等的工作原理。

我建议你先了解每个提供的函数的功能，然后用 readline 创建一个简单的提示符。设置完成后，就可以开始了。我个人先完成了执行器部分，先从内置命令开始，再用路径查找器查找 PATH 环境变量中未内置的命令，最后才开始执行执行器。



同学A的具体任务清单：

第一周任务：
实现基础令牌分割
处理简单命令: ls -l
识别重定向符号: > < >>
识别管道符号: |

第二周任务：
实现引号处理（单引号、双引号）
处理转义字符 \
实现变量扩展 $VAR
构建命令数据结构

第三周任务：
语法错误检测
处理here document <<
内存管理：释放解析器分配的内存
边界情况处理



同学B的具体任务清单：

第一周任务：
实现简单命令执行 ls, pwd
实现内建命令 echo, pwd, cd
基础进程管理 fork(), execve(), waitpid()

第二周任务：
实现输入/输出重定向 <, >
实现管道 |（单个管道）
实现 exit, env 命令
处理文件描述符泄漏

第三周任务：
实现追加重定向 >>
实现here document <<
信号处理 Ctrl+C, Ctrl+\, Ctrl+D
多管道支持 cmd1 | cmd2 | cmd3

数据结构接口：

// 同学A提供的数据结构
typedef struct s_command {
    char **args;           // 命令和参数
    char *input_file;      // 输入文件（NULL表示无）
    char *output_file;     // 输出文件（NULL表示无）
    int append_mode;       // 输出是否追加
    char *heredoc_delimiter; // here document分界符
    struct s_command *next;  // 管道下一个命令
} t_command;

// 同学A提供的函数
t_command *parse_input(char *input);
void free_commands(t_command *cmd);
执行器接口：
c
// 同学B提供的函数  
int execute_commands(t_command *cmd);
int execute_builtin(char **args);
void setup_redirections(t_command *cmd);

同学B：执行器部分
核心职责：执行解析后的命令结构
1. 进程执行管理
c
// 执行外部命令流程：
1. fork() 创建子进程
2. 在子进程中:
   - 设置重定向 (dup2)
   - execve() 执行命令
3. 在父进程中:
   - waitpid() 等待子进程结束
   - 收集退出状态

// 示例执行: ls -l
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    execve("/bin/ls", {"ls", "-l", NULL}, environ);
} else {
    // 父进程  
    waitpid(pid, &status, 0);
}
2. 内建命令实现
c
// 必须实现的内建命令：
- cd:     改变工作目录
- echo:   输出文本，支持 -n 选项
- pwd:    打印当前目录
- export: 设置环境变量
- unset:  取消环境变量
- env:    显示环境变量
- exit:   退出shell

// 示例：cd 命令实现
int builtin_cd(char **args) {
    if (args[1] == NULL) {
        chdir(getenv("HOME"));
    } else {
        if (chdir(args[1]) != 0) {
            perror("cd");
            return 1;
        }
    }
    return 0;
}
3. 重定向处理
c
// 处理所有重定向类型：
- 输入重定向:    cmd < file.txt
- 输出重定向:    cmd > file.txt  
- 追加重定向:    cmd >> file.txt
- here document: cmd << EOF

// 重定向执行流程：
1. 打开文件获取fd
2. 使用dup2重定向stdin/stdout
3. 执行命令
4. 恢复原来的stdin/stdout
4. 管道实现
c
// 处理: cmd1 | cmd2 | cmd3
int pipefd[2];
pipe(pipefd);

// 第一个命令：输出重定向到管道
dup2(pipefd[1], STDOUT_FILENO);
close(pipefd[1]);

// 第二个命令：输入来自管道  
dup2(pipefd[0], STDIN_FILENO);
close(pipefd[0]);
5. 信号处理
c
// 关键信号处理：
- SIGINT (Ctrl+C):  中断当前命令
- SIGQUIT (Ctrl+\): 退出当前命令
- EOF (Ctrl+D):     退出shell

void handle_sigint(int sig) {
    write(1, "\nminishell> ", 12);
}
