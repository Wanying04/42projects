Philosophers

哲学家

Nunca pensé que la filosofía llegara a ser tan letal

我从未想过哲学竟然如此致命。

Resumen:
En este proyecto, aprenderás los principios básico de hilar un proceso.
Vas a aprender a como crear hilos y descubrirás los mutex.

摘要：
在本项目中，你将学习线程的基本原理。
你将学会如何创建线程，并了解互斥锁。

Instrucciones generales

一般说明

• Tu proyecto deberá estar escrito en C.
• Tu proyecto debe estar escrito siguiendo la Norma. Si tienes archivos o funciones adicionales, estas están incluidas en la verificación de la Norma y tendrás un 0 si hay algún error de norma en cualquiera de ellos.
• Tus funciones no deben terminar de forma inesperada (segfault, bus error, double free, etc) excepto en el caso de comportamientos indefinidos. Si esto sucede, tu proyecto será considerado no funcional y recibirás un 0 durante la evaluación.
• Toda la memoria asignada en el heap deberá liberarse adecuadamente cuando sea necesario. No se permitirán leaks de memoria.
• Si el enunciado lo requiere, deberás entregar un Makefile que compilará tus archivos fuente al output requerido con las flags -Wall, -Werror y -Wextra, utilizar cc y por supuesto tu Makefile no debe hacer relink.
• Tu Makefile debe contener al menos las normas $(NAME), all, clean, fclean y re.
• Para entregar los bonus de tu proyecto deberás incluir una regla bonus en tu Makefile, en la que añadirás todos los headers, librerías o funciones que estén prohibidas en la parte principal del proyecto. Los bonus deben estar en archivos distintos _bonus.{c/h}. La parte obligatoria y los bonus se evalúan por separado.
• Si tu proyecto permite el uso de la libft, deberás copiar su fuente y sus Makefile asociados en un directorio libft con su correspondiente Makefile. El Makefile de tu proyecto debe compilar primero la librería utilizando su Makefile, y después compilar el proyecto.
• Te recomendamos crear programas de prueba para tu proyecto, aunque este trabajo no será entregado ni evaluado. Te dará la oportunidad de verificar que tu programa funciona correctamente durante tu evaluación y la de otros compañeros.
Y sí, tienes permitido utilizar estas pruebas durante tu evaluación o la de otros compañeros.
• Entrega tu trabajo en tu repositorio Git asignado. Solo el trabajo de tu repositorio Git será evaluado. Si Deepthought evalúa tu trabajo, lo hará después de tus compañeros. Si se encuentra un error durante la evaluación de Deepthought, esta habrá terminado.

• 您的项目必须使用 C 语言编写。
• 您的项目必须遵循标准。如果您有其他文件或函数，这些文件或函数将包含在标准检查中，如果其中任何一个文件或函数存在任何标准错误，您将获得 0 分。
• 您的函数不得意外终止（段错误、总线错误、重复释放等），除非出现未定义行为。如果发生这种情况，您的项目将被视为无法运行，并且在评估期间您将获得 0 分。
• 所有在堆上分配的内存都必须在必要时正确释放。不允许出现内存泄漏。
• 如果项目需要，您必须提交一个 Makefile，该文件会使用 -Wall、-Werror 和 -Wextra 标志将您的源文件编译为所需的输出，并使用 cc，当然，您的 Makefile 不得重新链接。
• 您的 Makefile 必须至少包含 $(NAME)、all、clean、fclean 和 re 规则。
• 要为您的项目提交奖励，您必须在 Makefile 中包含一条奖励规则，在该规则中添加项目主体部分中禁止使用的所有头文件、库或函数。奖励必须放在单独的 _bonus.{c/h} 文件中。强制部分和奖励部分将分别评估。
• 如果您的项目允许使用 libft，您必须将其源代码和相关的 Makefile 复制到包含其对应 Makefile 的 libft 目录中。项目的 Makefile 必须先使用其 Makefile 编译库，然后再编译项目。
• 我们鼓励您为您的项目创建测试程序，尽管这些程序不会被提交或评估。这将使您有机会在您和其他同事的评估过程中验证您的程序是否正常运行。
是的，您可以在您或其他同事的评估过程中使用这些测试。
• 将您的作品提交到您指定的 Git 仓库。只有您 Git 仓库中的作品才会被评估。如果 Deepthought 评估您的作品，它将在您的作品之后进行评估。如果在 Deepthought 评估过程中发现错误，则评估完成。

Descripción general

概述

Aquí tienes una lista de cosas que deberías conocer si quieres superar este proyecto:

如果你想通过这个项目，你需要了解以下几点：

• Uno o más filósofos se sientan en una mesa redonda.
En el centro de la mesa se encuentra un gran bol de espaguetis.
• Los filósofos solo pueden comer, pensar, o dormir.
Mientras están comiendo, no pueden pensar ni dormir;
Mientras están pensando, no pueden dormir ni comer;
Y, por supuesto, mientras están durmiendo, no pueden comer ni pensar.
• También hay tenedores en la mesa, tantos tenedores como filósofos.
• Porque coger y comer espaguetis con un solo tenedor puede ser incomodo, los filósofos deben tomar el tenedor de la derecha y el de la izquierda, uno en cada mano.
• Cuándo un filósofo termine de comer, dejará los tenedores en la mesa e inmediatamente empezará a dormir. Una vez se despierte, empezará a pensar nuevamente.
La simulación se detendrá cuando un filósofo muere por inanición.
• Todos los filósofos necesitan comer y nunca deben morir de hambre.
• Los filósofos no hablan entre ellos.
• Los filósofos no saben si otro filósofo va a morir.
• ¡No debería hacer falta decir que todos deben evitar morir!

• 一位或多位哲学家坐在一张圆桌旁。
桌子中央放着一大碗意大利面。
• 哲学家只能吃饭、思考或睡觉。
吃饭时，他们不能思考或睡觉；
思考时，他们不能吃饭或睡觉；
当然，睡觉时，他们也不能吃饭或思考。
• 桌子上还有叉子，叉子的数量与哲学家的数量相同。
• 由于只用一把叉子拿起意大利面吃起来比较笨拙，所以哲学家必须一手拿起左右两把叉子。
• 当哲学家吃完后，他们会把叉子留在桌子上，然后立即睡觉。醒来后，他们会重新开始思考。
当哲学家饿死时，模拟将停止。
• 所有哲学家都需要吃饭，永远不应该挨饿。
• 哲学家之间不互相交谈。
• 哲学家不知道其他哲学家是否会死。
• 毋庸置疑，每个人都应该避免死亡！

Instrucciones generales

一般说明

Deberás escribir un programa para la parte obligatoria y otro para la parte bonus (Solo
si decides hacer la parte bonus). Ambas tienen que cumplir con las siguientes reglas:

你必须为必修部分和奖励部分分别编写一个程序（仅当你决定完成奖励部分时）。两个程序都必须遵循以下规则：

• ¡Las variables globales están prohibidas!
• Tu(s) programa(s) debe(n) aceptar los siguientes argumentos:
number_of_philosophers time_to_die time_to_eat time_to_sleep
[number_of_times_each_philosopher_must_eat]
◦ number_of_philosophers: es el número de filósofos, pero también el número
de tenedores.
◦ time_to_die (en milisegundos): si un filósofo no empieza a comer en time_to_die
milisegundos desde el comienzo de su ultima comida o desde el principio de la
simulación, este morirá.
◦ time_to_eat (en milisegundos): es el tiempo que tiene un filósofo para comer.
Durante ese tiempo, tendrá los tenedores ocupados.
◦ time_to_sleep (en milisegundos): es el tiempo que tiene un filósofo para
dormir.
◦ number_of_times_each_philosopher_must_eat (argumento opcional): si todos los filósofos comen al menos number_of_times_each_philosopher_must_eat
veces, la simulación se detendrá. Si no se especifica, la simulación se detendrá
con la muerte de un filósofo.
• Cada filósofo tendrá asignado un número del 1 al number_of_philosophers.
• El filósofo número 1 se sentará al lado del filósofo número number_of_philosophers.
Cualquier otro filósofo número N se sentarán entre el filósofo número N - 1 y el filósofo
número N + 1.
Los logs de tu programa:
• Cualquier cambio de estado de un filósofo debe tener el siguiente formato:
◦ timestamp_in_ms X has taken a fork
◦ timestamp_in_ms X is eating
◦ timestamp_in_ms X is sleeping
◦ timestamp_in_ms X is thinking
◦ timestamp_in_ms X died
Reemplaza timestamp_in_ms con la marca de tiempo actual en milisegundos
y X con el numero del filósofo.
• El estado impreso no debe estar roto o alterado por el estado de otros filósofos
• No puedes tener más de 10ms entre la muerte de un filósofo y el momento en el que
imprimes su muerte.
• Te recuerdo, los filósofos deben evitar morir.

• 禁止使用全局变量！
• 你的程序必须接受以下参数：

number_of_philosophers time_to_die time_to_eat time_to_sleep
[number_of_times_each_philosopher_must_eat]

◦ number_of_philosophers：这是哲学家的数量，也是餐叉的数量。
◦ time_to_die（毫秒）：如果哲学家在最后一餐开始后或模拟开始后未在 time_to_die 毫秒内开始进食，他们将会死亡。
◦ time_to_eat（毫秒）：这是哲学家必须进食的时间。
在此期间，餐叉将被占用。
◦ time_to_sleep（毫秒）：这是哲学家必须睡觉的时间。
◦ number_of_times_each_philosopher_must_eat（可选参数）：如果所有哲学家都至少吃了 number_of_times_each_philosopher_must_eat，模拟将停止。如果未指定，则模拟将在哲学家死亡时停止。
• 每位哲学家将被分配一个从 1 到 number_of_philosophers 的编号。
• 1 号哲学家将坐在 number_of_philosophers 哲学家旁边。
任何其他编号为 N 的哲学家都将位于编号为 N - 1 和编号为 N + 1 的哲学家之间。
你的程序记录：
• 哲学家状态的任何变化都必须遵循以下格式：

◦ timestamp_in_ms X has taken a fork
◦ timestamp_in_ms X is eating
◦ timestamp_in_ms X is sleeping
◦ timestamp_in_ms X is thinking
◦ timestamp_in_ms X died

将 timestamp_in_ms 替换为当前时间戳（以毫秒为单位），
并将 X 替换为哲学家的编号。
• 打印的状态不得被其他哲学家的状态破坏或更改。
• 哲学家死亡和打印其死亡之间的时间间隔不能超过 10 毫秒。
• 记住，哲学家应该避免死亡。

Tu programa no debe tener ningún data races.

您的程序一定不能有任何数据竞争。

Parte obligatoria

必修部分

Nombre de programa 程序名称
philo

Archivos a entregar 需提交文件
Makefile, *.h, *.c, en el directorio philo/ （存放于philo/目录下）

Makefile
NAME, all, clean, fclean, re

Argumentos 参数
number_of_philosophers time_to_die time_to_eat time_to_sleep
[number_of_times_each_philosopher_must_eat]

Funciones autorizadas 允许使用的函数
memset, printf, malloc, free, write, usleep, gettimeofday, pthread_create, pthread_detach, pthread_join, pthread_mutex_init, pthread_mutex_destroy, pthread_mutex_lock, pthread_mutex_unlock

Se permite usar libft 允许使用 libft 库?
No 否

Descripción 描述
Philosophers con hilos y mutex 基于线程与互斥锁的哲学家问题

Las reglas específicas para la parte obligatoria son:

必修部分的具体规则如下：

• Cada filósofo debe ser un hilo.
• Hay un tenedor entre cada filósofo. por lo tanto, si hay varios filósofos, cada filósofo debe tener un tenedor a su izquierda y otro a su derecha. si solo hay un filósofo, solo habrá un tenedor en la mesa.
• Para prevenir que los filósofos dupliquen los tenedores, deberás proteger los estados de los tenedores con un mutex por cada uno de ellos.

• 每位哲学家必须作为独立线程运行。
• 每位哲学家之间放置一把叉子。因此若存在多位哲学家，每位哲学家左侧和右侧各需放置一把叉子。若仅有一位哲学家，餐桌上仅需放置一把叉子。
• 为防止哲学家重复取用餐具，需为每把餐具设置互斥锁以保护其状态。

Bonus
...
基于进程与信号量的哲学家问题

Entrega y evaluación

提交与评估

Entrega tu proyecto en tu repositorio Git como de costumbre. Solo el trabajo en tu repositorio será evaluado durante la defensa. No dudes en verificar dos veces los nombres de tus archivos para segurarte que sean los correctos.
Directorio parte obligatoria : philo/
Directorio parte bonus : philo_bonus/

按常规方式将项目提交至您的Git仓库。答辩期间仅评估您仓库中的工作成果。请务必仔细核对文件名是否正确。
必修部分目录：philo/
选修部分目录：philo_bonus/





